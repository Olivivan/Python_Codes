<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3D Globe Map</title>
    <style>
      body { margin: 0; overflow: hidden; font-family: Arial, Helvetica, sans-serif }
      #globeViz { position: absolute; top: 0; left: 0; right: 0; bottom: 0 }
      #controls { position: absolute; left: 10px; top: 10px; background: rgba(255,255,255,0.9); padding: 8px; border-radius:6px; z-index:10 }
      #search { width: 200px }
      .btn { margin: 2px }
    </style>
  </head>
  <body>
    <div id="globeViz"></div>
    <div id="controls">
      <div>
        <input id="search" placeholder="Search city..." />
        <button id="btnSearch">Search</button>
      </div>
      <div style="margin-top:6px">
        <label><input type="checkbox" id="togglePoints" checked /> Show points</label><br>
        <label><input type="checkbox" id="toggleArcs" checked /> Show arcs</label>
      </div>
      <div style="margin-top:6px">
        <button id="zoomIn" class="btn">Zoom In</button>
        <button id="zoomOut" class="btn">Zoom Out</button>
      </div>
      <div style="margin-top:6px; font-size:12px; color:#333">Tip: drag to rotate globe</div>
    </div>

    <!-- Load dependencies from CDN -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three-globe"></script>
    <script>
      // Basic three-globe + three.js scene setup
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('globeViz').appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera();
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      camera.position.z = 300;

      // Stronger, warmer lighting for better visibility
      const ambient = new THREE.AmbientLight(0xffffff, 0.9);
      scene.add(ambient);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
      directionalLight.position.set(5, 3, 5);
      scene.add(directionalLight);
      const hemi = new THREE.HemisphereLight(0xaaaaee, 0x444444, 0.6);
      scene.add(hemi);

      // Use a brighter daytime earth texture and topology for a less-dark appearance
      const Globe = new ThreeGlobe({animateIn: true})
        .globeImageUrl('https://unpkg.com/three-globe/example/img/earth-day.jpg')
        .bumpImageUrl('https://unpkg.com/three-globe/example/img/earth-topology.png');

      scene.add(Globe);

      // Controls state
      let pointsMesh = null; // handled by three-globe
      // store arcs outside so toggle works
      let arcs = [];

      // Load data
      let markers = [];
        fetch('/data').then(r => r.json()).then(data => { markers = data || []; });

        // Create some arcs for demo connecting each to the first
        arcs = [];
        if (markers.length > 1) {
          for (let i=1;i<markers.length;i++) {
            arcs.push({
              startLat: markers[0].lat, startLng: markers[0].lon,
              endLat: markers[i].lat, endLng: markers[i].lon,
              color: [['rgba(255,0,0,0.6)', 'rgba(0,255,0,0.6)']]
            });
          }
        }
        Globe.arcsData(arcs)
             .arcColor(d => d.color[0][0])
             .arcStroke(d => 0.5)
             .arcDashLength(0.4)
             .arcDashGap(4)
             .arcDashInitialGap(() => Math.random() * 5)
             .arcDashAnimateTime(1000);
      });

      // Resize handling
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });

      // Basic auto-rotation
      let rotationSpeed = 0.002;
      function animate() {
        Globe.rotation.y += rotationSpeed;
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();

      // Utility: convert lat/lng to 3D cartesian on sphere radius
      function latLngToCartesian(lat, lon, radius=100) {
        const phi = (90 - lat) * Math.PI / 180;
        const theta = (lon + 180) * Math.PI / 180;
        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        const y = radius * Math.cos(phi);
        return new THREE.Vector3(x,y,z);
      }

      // Controls: search, zoom, and pointer drag-to-rotate

      // Highlight management
      let highlight = null;
      function clearHighlight() {
        if (highlight) {
          scene.remove(highlight);
          try { highlight.geometry.dispose(); } catch(e){}
          try { highlight.material.dispose(); } catch(e){}
          highlight = null;
        }
      }

      // Search handler: calls server-side /search?q=
      document.getElementById('btnSearch').onclick = async () => {
        const qraw = document.getElementById('search').value || '';
        const q = qraw.trim();
        if (!q) return;
        try {
          const res = await fetch('/search?q=' + encodeURIComponent(q));
          const results = await res.json();
          if (!results || results.length === 0) { alert('No match for: ' + qraw); return; }
          const found = results[0];
          // center camera
          const target = latLngToCartesian(found.lat, found.lon, 100);
          const newCamPos = target.clone().multiplyScalar(2.2);
          camera.position.copy(newCamPos);
          camera.lookAt(target);
          rotationSpeed = 0;

          // add a temporary highlight sphere
          clearHighlight();
          const geom = new THREE.SphereGeometry(2.5, 16, 12);
          const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
          highlight = new THREE.Mesh(geom, mat);
          highlight.position.copy(target);
          scene.add(highlight);
          // remove highlight after 8s
          setTimeout(clearHighlight, 8000);
        } catch (err) {
          console.error(err);
          alert('Search failed');
        }
      };

      // Zoom buttons
      document.getElementById('zoomIn').onclick = () => { camera.position.multiplyScalar(0.85); };
      document.getElementById('zoomOut').onclick = () => { camera.position.multiplyScalar(1.15); };

      // Mouse wheel zoom (scroll) â€” works on the canvas
      renderer.domElement.addEventListener('wheel', (ev) => {
        ev.preventDefault();
        const delta = Math.sign(ev.deltaY) * Math.min(5, Math.abs(ev.deltaY));
        const factor = delta > 0 ? 1.08 : 0.92;
        camera.position.multiplyScalar(factor);
      }, { passive: false });

      // Pointer drag to rotate globe (grab-to-drag)
      let isDragging = false;
      let lastX = 0, lastY = 0;
      const dragSensitivity = 0.005; // tweak for responsiveness

      // Set hand-like cursor on the canvas
      renderer.domElement.style.cursor = 'grab';

      renderer.domElement.addEventListener('pointerdown', (ev) => {
        isDragging = true;
        lastX = ev.clientX;
        lastY = ev.clientY;
        rotationSpeed = 0; // stop auto-rotate while user interacts
        try { ev.target.setPointerCapture(ev.pointerId); } catch(e) {}
        renderer.domElement.style.cursor = 'grabbing';
      });

      renderer.domElement.addEventListener('pointermove', (ev) => {
        if (!isDragging) return;
        const dx = ev.clientX - lastX;
        const dy = ev.clientY - lastY;
        lastX = ev.clientX; lastY = ev.clientY;
        // rotate globe: horizontal drag -> y-rotation, vertical drag -> x-rotation
        Globe.rotation.y += dx * dragSensitivity;
        Globe.rotation.x += dy * dragSensitivity;
        // clamp x rotation to avoid flipping over
        const maxX = Math.PI / 2 - 0.01;
        if (Globe.rotation.x > maxX) Globe.rotation.x = maxX;
        if (Globe.rotation.x < -maxX) Globe.rotation.x = -maxX;
      });

      function endDrag(ev) {
        isDragging = false;
        try { ev.target.releasePointerCapture && ev.target.releasePointerCapture(ev.pointerId); } catch(e) {}
        renderer.domElement.style.cursor = 'grab';
      }

      renderer.domElement.addEventListener('pointerup', endDrag);
      renderer.domElement.addEventListener('pointercancel', endDrag);
      renderer.domElement.addEventListener('pointerleave', endDrag);

      // Toggle layers
      document.getElementById('togglePoints').onchange = (e) => {
        Globe.pointsData(e.target.checked ? markers : []);
      };
      document.getElementById('toggleArcs').onchange = (e) => {
        Globe.arcsData(e.target.checked ? arcs : []);
      };

    </script>
  </body>
</html>
